\documentclass[../main.tex]{subfiles}
\chapter{Simulation}
\label{c:simulation}

\begin{figure}
	\includegraphics[scale=0.75]{vf1-flowchart}
	\caption{Hier ist die caption}
	\label{fig:flowchart}
\end{figure}

Abbildung \ref{fig:flowchart} zeigt das Flussbild der Simulation.
Der Ablauf der Simulation ist unterteilt in die Abschnitte Findung der Startkonfiguration, Durchführung der Schnitte mit den Lösungsiterationen, Erkennung des Schnittendes sowie Nachbereitung des Schnittes und schließlich Abschluss der Simulation.
Neben der Ausführung des Simulationscodes sollte der Status der Berechnung in Form von grafischen Ausgaben dargestellt werden.
Das Plotten von Daten in Echtzeit ist schwierig zu realisieren in \matlab, vor Allem bei dreidimensionalen Datensätzen.
Die standardmäßig zur Verfügung gestellten Routinen sind nicht gut optimiert für schnelle Ausführungszeit und es ist notorisch schwierig \matlab Code multithread-fähig zu gestalten.
Die Lösungsansätze um trotz dieser Herausforderungen die für die grafische Ausgabe beanspruchte Rechenzeit effizient zu nutzen und die Simulation möglichst geringfügig zu belasten wird ebenfalls besprochen.


Die einzelnen Prozessschritte der Simulation werden im Folgenden erläutert.

\section{Vorbereitung der Simulation}
Vor Beginn der Simulation wird die Simulationssteuerungsparameter eingelesen.
Dabei werden zunächst die Eingabedaten des betrachteten Falles festgelegt.
Mit folgende Parameter kann definiert werden, wie dieser Fall gestaltet ist:
\begin{itemize}
	\item Zähnezahl des Zahnrades
	\item Modul des Zahnrades
	\item Geometrie des des Werkzeuges (Durchmesser, Kopf- und Fußhöhe)	
\end{itemize}
Aus diesen Parametern können weitere Startbedingungen ermittelt werden.
So ist die Startposition des Werkzeugs und den daraus folgenden Positionen der Maschinenkomponenten zu berechnen wie sie in Abschnitt \ref{c:maschkomppos} besprochen wurden.
Die Position der X-Achse der Maschine wird berechnet über den Achsabstand des gedachten Schneckengetriebes nach \cite[Gleichung 23.4]{Matek2017}:
\begin{equation*}
	a = \frac{d_{s1}+d_{s2}}{2}
\end{equation*}
\begin{eqdscr}{$d_{s1}$, $d_{s2}$}
	\item[$a$] Achsabstand
	\item[$d_{s1}$, $d_{s2}$] Teilkreisdurchmesser von Schneckenrad und Schnecke
\end{eqdscr}
Der Teilkreisdurchmesser des Schneckenrades wird berechnet nach \cite{Matek2017}:
\begin{equation*}
	d_{s1} = m \cdot z
\end{equation*}
\begin{eqdscr}{$m$}
	\item[$m$] Modul
	\item[$z$] Zähnezahl des Werkstückes
\end{eqdscr}
Der Vorschubfaktor der X-Achse $\feed{X}{\wz}$ ist im betrachteten Fall 0, sie verändert also ihre Position ausgehend von der Startposition im Verlauf der Simulation nicht.

Für den Startwert der Y-Achse müssen die Größen $y$, Achsverschiebung im Ausgang, und $\yshift$ festgelegt werden.
Ebenso ist für den Achsvorschub der Y-Achse $\feed{Y}{\wz}$ ein Wert einzugeben.
Diese Größen sind im betrachteten Fall 0.
Die Y-Achse verändert im betrachteten Fall ihrer Position ausgehend von ihrem Startwert nicht.

Danach wird die Werkzeuggeometrie erzeugt.
Wie in Kapitel \ref{c:werkzeugkinematik} erläutert wird die Geometrie des Werkzeuges in Polarkoordinaten beschrieben.
Dabei wird im aktuellen Stand das Bezugsprofil durch vier Eckpunkte dargestellt, deren Koordinaten mit einem Algorithmus von \scherbarth berechnet werden.
Da eine Zahnstange als Zahnrad mit unendliche großer Zähnezahl verstanden werden kann, hat sie gerade Flanken \cite[Kap. 3]{Widmer1981}.
Eine Annäherung der Zahnstange mit vier Punkten ist deswegen zweckmäßig, obwohl Verrundungen am Zahnkopf damit noch nicht dargestellt werden können.

Die Simulation beginnt mit einem Ebenenindex m von 1.
Es wird davon ausgegangen, dass die erste ebene des Werkstücks geschnitten wird.
Vor jedem Schnitt wird dann die oberste Ebene ermittelt, die eine valide Schnittkonfiguration hervorbringt.
Wie diese Erkennung funktioniert wird in Abschnitt \ref{c:seeken} erläutert.

\section[Startkonfiguration]{Finden der Startkonfiguration}
\label{c:startkonfig}
Der erste Schritt zur Findung der Startkonfiguration bei jeder Werkzeugumdrehung ist die Suche nach einer Werkzeugkonfiguration bei welcher Kontakt zwischen Werkzeug und Werkstück auftritt.
Dieser Vorgang wird als Seeken, eine deutsche Form des englischen Wortes für ,,Suchen'', bezeichnet.
Dabei wird das Werkzeug im freien Raum rotiert bis Kontakt auftritt.
Im Anschluss wird dann eine validen Schnittkonfiguration gesucht.

Eine valide Schnittkonfiguration tritt auf, wenn die auf eine diskrete Ebene des Werkstücks projizierte Geometrie der Schneide Überdeckung mit der Werkstückgeometrie hat.
Bei der vorliegenden Simulation ist das Werkstück entlang seiner Ausdehnung in z-Richtung in diskrete Ebenen unterteilt, welche das Werkzeug auf der jeweiligen Höhe in $z$ schneiden.
Die dabei entstehende Verschneidungsgeometrie des Werkstücks mit der Ebene ist eine zweidimensionale Geometrie.
Diese Geometrie ist ein Polygon, welches mit der Menge diskreter Punkte beschrieben, welche die Ecken des Polygons bilden.
Die Beschreibung von Werkstück und Werkzeug als Polygone wird in Abschnitt \ref{c:schnitte} im Detail beschrieben.

Seeken geschiet in der Seek-Schleife, die auch im Flussdiagrams in Abbildung \ref{fig:flowchart} beschrieben ist.
Dabei wird der Winkel des Werkzeugs ausgehend vom seiner Startkonfiguration mit einer bedatbaren Schrittweite inkrementiert, bis ein Punkt der Werkzeugschneide in der Hüllgeometrie des Werkstücks liegt.
Befindet sich ein Punkt des Werkzeugs in Hüllgeometrie des Werkstücks ist das Werkzeug ,,engaged'', von englisch ,,eingerastet''; die Schneide befindet sich im Eingriff.

Die Hüllgeomtrie des Werkstücks entspricht der Form des Rohmaterials, also ein Zylinder mit dem Durchmesser und der Höhe des Werkstücks.
Die Lage des Werkstücks entlang der z-Achse des Bearbeitungstischkoordinatensystems ist definierbar.

Engagement wird in der Funktion \code{checkEng} durch Vergleich der Position der Schneidenecken mit der Ausdehnung des Werkstücks erkannt.
Dabei ist es geschickt die Position der Schneidenecken in Zylinkerkoordinaten zu beschreibenen.
Vergleichbar zu den deckungsgleichen kartesischen und zylindrischen Koordinatensystemen des Werkzeugs, kann auch das Werkstück in kartesischen und zylindrischen Koordinatensystemen beschrieben werden.
Dieses Zylinderkoordinatensystem ist im Ursprung des kartesischen Werkzeugkoordinatensystems aufgespannt.
Die Koordinaten eines Punktes werden dann durch einen Winkel, einen Radius und eine Höhe in z-Richtung beschrieben.

Damit ein Punkt des Werkzeugs als engaged gilt, müssen zwei Bedingungen erfüllt sein:
Zum einen muss der der Abstand des Punktes zum Ursprung kleiner als der Radius des Werkstücks sein.
Zum anderen muss der Wert seiner z-Koordinate im Interval der Ausdehung des Werkstücks liegen.
Der Winkel des Punktes spielt zur Engagementerkennung keine Rolle.
Der Abstand $d$ des Punktes zum Ursprung wird als euklidische Norm berechnet nach \cite{mwVecnorm}:
\begin{equation*}
	d = \|v\| = \sqrt{\sum_{k=1}^{N} \|v_k\|^2}
\end{equation*}
Die Funktion gibt dann als logischen Wert zurück, ob der Werkzeugpunkt engaged ist oder nicht.

Das Ziel des Findens der Startkonfiguration es, die Rotation des Werkzeuges zu finden, bei welcher das Werkzeug das Werstück gerade berührt.
Der Seek liefert einen Werkzeugwinkel, der in der Nähe dieser Konfiguration liegt.
Durch Verkleinerung der Schrittweite beim Seeken, kann die Lösungskonfiguration dieses Näherungsverfahrens näher an die tatsächliche Lösung geführt werden.
Allerdings muss die Berechnung des Engagements, also des Eingriffs der Schneide, für jeden Iterationsschritt erfolgen und sollte deswegen sehr günstig sein, also wenig Rechenzeit in Anspruch nehmen.
Gleichzeit muss ein Kompromiss zwischen der Größe der Schrittweite beim Seeken und der dafür notwendigen Rechenzeit gefunden werden.
Allerdings kann mit einem nachträglichen Schritt eine Lösungskonfiguration weit innerhalb des Werkstück-Envelopes geschickt ausgeglichen werden.

Sobald durch Iteration eine Konfiguration gefunden wurde, die als engaged gewertet wird, kann der so gefundene Winkel des Werkzeugs $B$ als Eingangswert $B_0$ für Gleichung \ref{eq:loesung} verwendet werden.
Neben dem Startwert $B_0$ sind für diese Funktion zur Lösung noch zwei Größen notwendig.

Zum einen muss die Höhe der Ebene in z für die gelöst werden soll gegeben sein.
Andererseit muss die Lösung der Funktion verschoben werden, um den bereits zurück gelegten Winkel des Werkzeugs.

Dies geschieht über den Vorfaktor $k$.
Beim ersten Schnitt des Werkzeugs ist der Vorfaktor 1, weil die Startposition des Werkzeugs auf der xz-Ebene im Koordinatensystem in Abbildung \ref{fig:hobspindle_coord} ist.
Die Lösung des Werkzeugwinkels muss im zweiten oder dritten Quadranten des Koordinatensystems liegen.
Der Lösungsbereich des Arkussinus ist $\left[-\frac{\pi}{2}, \frac{\pi}{2}\right]$.
Es muss also $1 \cdot \pi$ addiert werden um eine Lösung im dritten Quadranten, mit Wertebereich $\left[\frac{\pi}{2}, \frac{3\cdot \pi}{2}\right]$, zu erhalten.

Es ist also noch nicht bekannt, auf welcher Ebene das Werkzeug das Werkzeug initial berührt.
Auf dieser Ebene soll der Punkt des Werkzeugs, für den gelöst wird, liegen und der Wert der z-Koordinate dieser Ebene wird in Gleichung \ref{eq:loesung} als $z_{soll}$ bezeichnet.
Am Anfang der Simulation ist die geometrische Beziehung von Werkzeug und Werkstück unbekannt.
Die initiale Schnittebene kann aber geschickt durch ein iteratives Verfahren gefunden werden.
Gleichung \ref{eq:loesung} wird für einen Wert für $z_{soll}$ gelöst.
Anschließend wird für die Lösung $B$ geprüft, ob sich das Werkzeug in dieser Konfiguration engaged ist.
Ist dies nicht der Fall

Dabei erhält man eine Lösung für $B$
Das Erkennen einer Engagementkonfiguration geschieht durch Vergleichen der Eckkoordinaten der Schneide

Nach Finden einer Werkzeugkonfiguration bei der mindes

\section{Durchführen der Schnitte}
\label{c:schnitte}
ist eine Position des Werkzeuges, bei der es durch Projektion der Schneide des Werkzeuges auf eine Werkstückebene zu einer Überlagerung kommt.
Werkzeug und Werkstück werden in der Simulation als Polygone repräsentiert, die in Matlab als Objekt der Klasse polyshape dargestellt werden.
Polyshape Objekte haben Methoden, die es erlauben Verschneidungsoperationen durchzuführen.
Dabei wird von einem polyshape Objekte die Geomtrie abgezogen, die von dem anderen Polygon überlagert wird.
\begin{figure}
	\includegraphics{uberlagerung}
	\caption{Hier ist die caption}
	\label{fig:uberlagerung}
\end{figure}
Bei einer Überlagerung


\section{Plotten}
Die Architektur des Codes erlaubt das parallel zum Lösen des mathematischen Problems die Ausgabe erfolgt mit minimalem Einfluss auf die Ausführungsgeschwindigkeit der Berechnung.
Das wurde erreicht durch die Auslagern des Plottens in eine Klasse.
